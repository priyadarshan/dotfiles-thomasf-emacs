#+TITLE: Thomas Frössmans gnu emacs configuration
#+AUTHOR: Thomas Frössman
#+EMAIL: thomasf@jossystem.se
#+TAGS: issue(i)
#+TODO: TODO DONE
#+LANGUAGE: en
#+PROPERTY: exports code
#+PROPERTY: no-expand
#+OPTIONS: toc:2 num:nil ^:nil
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t TeX:t LaTeX:nil skip:nil d:t tags:not-in-toc
#+INFOJS_OPT: view:showall toc:t ltoc:t mouse:underline buttons:0 sdepth:2 path:../org-res/org-info.js
#+STYLE:    <link rel="stylesheet" type="text/css" href="../org-res/style.css" />
#+STARTUP:indent
#+STARTUP:hidestars

* Introduction
This is very very much a work in progress..
I'm both quite new to org mode and have just
recently started merging all my config files
together using org-babel in this file.

Some things has even stopped working,
I'll fix things as I miss them.

* Files and headers
** thomasf-init.el
Bootstrap
#+begin_src emacs-lisp :tangle thomasf-init.el
;;
;; DO NOT EDIT THIS FILE BY HAND!
;; This file is generated from thomasf-emacs.org
;;

(provide 'thomasf-init)
#+end_src

** thomasf-emacs.el
Main configuration file
#+begin_src emacs-lisp
;;
;; DO NOT EDIT THIS FILE BY HAND!
;; This file is generated from thomasf-emacs.org
;;
#+end_src

** thomasf-org.el
All orgmode configuration
#+begin_src emacs-lisp :tangle thomasf-org.el
;;
;; DO NOT EDIT THIS FILE BY HAND!
;; This file is generated from thomasf-emacs.org
;;

(provide 'thomasf-org)
#+end_src

** thomasf-gui.el
Stuff that only should load when a window system is available.

#+begin_src emacs-lisp :tangle thomasf-gui.el
;;
;; DO NOT EDIT THIS FILE BY HAND!
;; This file is generated from thomasf-emacs.org
;;

(provide 'thomasf-gui)
#+end_src
* Bootstrap
** Turn off unwanted UI elements at once
To avoid momentary display
#+begin_src emacs-lisp :tangle thomasf-init.el
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+end_src

** Less clutter and distractions on start up
#+begin_src emacs-lisp :tangle thomasf-init.el
(setq inhibit-startup-message t
      inhibit-splash-screen t
      inhibit-startup-buffer-menu t
      inhibit-startup-echo-area-message t
      initial-scratch-message ";; scratch buffer -- remember to be happy, maybe, etc. \n\n"
      )
#+end_src
** Emacs24 version check
#+begin_src emacs-lisp :tangle thomasf-init.el
  (when (or (not (boundp 'emacs-version))
            (string< emacs-version "24.0"))
    (error (concat "emacs config requires Emacs 24.0 or later.")))
#+end_src
** Set up load paths early Provide the org-mode environment at once
Because babel should not have any chance to load from anywhere else
#+begin_src emacs-lisp :tangle thomasf-init.el
(setq vendor-dir (concat dotfiles-dir "vendor/"))
(setq notes-dir (file-truename "~/notes/"))

(let ((default-directory vendor-dir))
  (setq load-path
        (append
         (let ((load-path (copy-sequence load-path)))
           (append
            (copy-sequence (normal-top-level-add-to-load-path '(".")))
            (normal-top-level-add-subdirs-to-load-path)))
         load-path)))
(setq org-modules '(org-bibtex org-docview org-id org-info org-jsinfo org-habit org-mew org-mhe org-vm org-wl org-w3m org-git-link org-velocity))
(require 'cl)
(require 'org-install)
#+end_src

** Load thomasf-init if it's not loaded already
If dotfiles-dir is not set, set it to the directory of
this file and add that directory to the load path.
#+begin_src emacs-lisp
  (unless (boundp 'dotfiles-dir)
    (setq dotfiles-dir (file-name-directory (or load-file-name (buffer-file-name))))
    (add-to-list 'load-path dotfiles-dir))
#+end_src

Make sure that the init file is loaded.
#+begin_src emacs-lisp
(require 'thomasf-init)
#+end_src

* Startup
** Path variables and load paths
Themes load paths
#+begin_src emacs-lisp
(setq themes-dir (concat dotfiles-dir "themes/"))
(add-to-list 'load-path (concat themes-dir "solarized-bbatsov"))
(add-to-list 'custom-theme-load-path themes-dir)
(add-to-list 'custom-theme-load-path (concat themes-dir "solarized-bbatsov"))
#+end_src
** Files that should not be version controlled should gather in their own directory
#+begin_src emacs-lisp
  (setq local-data-dir (concat dotfiles-dir "localdata/"))

  (make-directory local-data-dir t)
  (defvar backup-dir (concat  local-data-dir "backups/" (user-real-login-name) "/"))
  (defvar autosave-dir (concat local-data-dir  "autosaves/" (user-login-name) "/"))
  (make-directory autosave-dir t)

  (setq save-place-file (concat local-data-dir "saveplace")
        savehist-file (concat local-data-dir "savehist")
        ac-comphist-file (concat local-data-dir "ac-comphist.dat")
        recentf-save-file (concat local-data-dir "recentf")
        bookmark-default-file (concat local-data-dir "bookmarks")
        org-clock-persist-file (concat local-data-dir "org-clock-save.el")
        org-id-locations-file (concat local-data-dir "org-id-locations")
        tramp-persistency-file-name (concat local-data-dir "tramp")
        tramp-backup-directory-alist backup-directory-alist
        backup-directory-alist (list (cons "." backup-dir))
        auto-save-file-name-transforms `((".*" ,autosave-dir t))
        custom-file (concat local-data-dir "custom-set-variables.el")
        smex-save-file (concat local-data-dir "smex-items")
        )
#+end_src
** Load package system
#+begin_src emacs-lisp
(require 'package)
(setq package-archives
      '(("original"    . "http://tromey.com/elpa/")
        ("gnu"         . "http://elpa.gnu.org/packages/")
        ("marmalade"   . "http://marmalade-repo.org/packages/")))
(package-initialize)
#+end_src
** Try to load private settings
#+begin_src emacs-lisp
(load "~/.emacs-private" 'noerror 'nomessage)
#+end_src
** Load customize set variables
#+begin_src emacs-lisp
(load custom-file 'noerror 'nomessage)
#+end_src
** Set up autoloads
#+begin_src emacs-lisp
  (autoload 'multi-web-mode "multi-web-mode" "Multi web mode" t)
  (autoload 'sws-mode "sws-mode" "Sws mode" t)
  (autoload 'jade-mode "jade-mode" "Jade mode" t)
  (autoload 'stylus-mode "stylus-mode" "Stylus mode" t)
  (autoload 'describe-unbound-keys "unbound" "Find unbound keys" t)
  (autoload 'zencoding-mode "zencoding-mode" "Zen coding mode" t)
  (autoload 'nyan-mode "nyan-mode" "Nyan mode" t)
  (autoload 'artbollocks-mode "artbollocks-mode" "Artbollocks mode" t)

  (autoload 'haskell-align-imports "haskell-align-imports" "haskell-align-imports" t)
  (autoload 'haskell-navigate-imports "haskell-navigate-imports" "haskell-navigate-imports" t)
  (autoload 'haskell-sort-imports "haskell-sort-imports" "haskell-sort-imports" t)

  (load "haskell-site-file")
  (load "50magit")

#+end_src
** Require whats always wanted
#+begin_src emacs-lisp
(require 'thomasf-org)
(if window-system (require 'thomasf-gui))
(require 'saveplace)
(require 'ffap)
(require 'uniquify)
(require 'ansi-color)
(require 'recentf)
(require 'undo-tree)
(smex-initialize)
;;(require 'smex)
(load "sv-kalender" 'noerror 'nomessage)
;; might want to auto load these instead
(require 'table)
;(require 'anything-config)
;(require 'sclang nil 'noerror)
#+end_src

New stuff, to want?
#+begin_src emacs-lisp
  (require 'nav)
;;  (require 'find-file-in-project)
#+end_src

* Common
** Use UTF8 as much as possible
#+begin_src emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")       ; prefer utf-8 for language settings
(set-input-method nil)                   ; no funky input for normal editing;
(setq read-quoted-char-radix 10)         ; use decimal, not octal
#+end_src

** UI related settings
#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src
** TODO Misc settings
What is what?
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t
        vc-handled-backends ()
        ring-bell-function 'ignore
        visible-bell nil
        column-number-mode t
        font-lock-maximum-decoration t

        transient-mark-mode t
        shift-select-mode nil
        delete-selection-mode nil
        set-mark-even-if-inactive t

        delete-by-moving-to-trash t
        truncate-partial-width-windows nil
        uniquify-buffer-name-style 'forward

        ;; whitespace-mode
        whitespace-line-column 100
        whitespace-style '(face
                           trailing
                           lines
                           space-before-tab
                           indentation
                           space-after-tab)

        ediff-window-setup-function 'ediff-setup-windows-plain
        x-select-enable-clipboard t
        interprogram-paste-function 'x-cut-buffer-or-selection-value

        browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "sensible-browser"



        tramp-default-method "ssh"
        anything-command-map-prefix-key "C-<f5>"

        ;;glasses-separator "␣"
        lexical-illusions nil
        )

  (setq-default tab-width 3
                indent-tabs-mode nil
                indicate-empty-lines nil
                imenu-auto-rescan t
                save-place t
                )

  (ansi-color-for-comint-mode-on)
  (auto-compression-mode t)
  (recentf-mode 1)
  (savehist-mode 1)
  (show-paren-mode 1)

  (nyan-mode 1)

  (electric-pair-mode t)
  (electric-indent-mode -1)
  (electric-layout-mode t)

  (setq show-paren-style 'parenthesis)

  ;; init random seed
  (random t)

  ;; use y/n prompts instead of yes/no
  (defalias 'yes-or-no-p 'y-or-n-p)


#+end_src
** Setup themes and gui stuff
#+begin_src emacs-lisp :tangle thomasf-gui.el
(setq day-mode-theme 'solarized-light
      night-mode-theme 'solarized-dark)

(load-theme day-mode-theme)

(require 'pretty-mode)
(global-pretty-mode 1)

#+end_src

** TODO Auto-complete
Have to creae a default autocomplete conf thats better

Current:

#+begin_src emacs-lisp
  (require 'auto-complete)
  (require 'auto-complete-config)
  (global-auto-complete-mode t)
  (setq ac-auto-start nil)
  (setq ac-dwim nil) ; To get pop-ups with docs even if a word is uniquely completed

  ;; MOVE TO KEYB?
  (define-key ac-completing-map (kbd "C-n") 'ac-next)
  (define-key ac-completing-map (kbd "C-p") 'ac-previous)

  ;;----------------------------------------------------------------------------
  ;; Use Emacs' built-in TAB completion hooks to trigger AC (Emacs >= 23.2)
  ;;
  (setq tab-always-indent 'complete)  ;; use 'complete when auto-complete is disabled
  (add-to-list 'completion-styles 'initials t)

  ;; hook AC into completion-at-point
  (defun set-auto-complete-as-completion-at-point-function ()
    (setq completion-at-point-functions '(auto-complete)))
  (add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)

  (set-default 'ac-sources
               '(ac-source-dictionary
                 ac-source-yasnippet
                 ac-source-words-in-buffer
                 ac-source-words-in-same-mode-buffers
                 ac-source-words-in-all-buffer))

  (dolist (mode '(magit-log-edit-mode log-edit-mode org-mode text-mode haml-mode
                                      sass-mode yaml-mode csv-mode espresso-mode haskell-mode
                                      html-mode nxml-mode sh-mode smarty-mode clojure-mode
                                      lisp-mode textile-mode markdown-mode tuareg-mode
                                      css-mode less-css-mode))
    (add-to-list 'ac-modes mode))

  ;; Exclude very large buffers from dabbrev
  (defun smp-dabbrev-friend-buffer (other-buffer)
    (< (buffer-size other-buffer) (* 1 1024 1024)))

  (setq dabbrev-friend-buffer-function 'smp-dabbrev-friend-buffer)
  (add-to-list 'ac-dictionary-directories (concat vendor-dir "auto-complete/dict/"))

  (ac-config-default)
#+end_src

Somethings to be inspired by?
#+begin_src emacs-lisp :tangle no
   (require 'auto-complete)
   (require 'auto-complete-config)
   (global-auto-complete-mode t)
   (setq ac-auto-start nil)
   (setq ac-dwim nil) ; To get pop-ups with docs even if a word is uniquely completed
   (define-key ac-completing-map (kbd "C-n") 'ac-next)
   (define-key ac-completing-map (kbd "C-p") 'ac-previous)

   ;;----------------------------------------------------------------------------
   ;; Use Emacs' built-in TAB completion hooks to trigger AC (Emacs >= 23.2)
   ;;----------------------------------------------------------------------------
   (setq tab-always-indent 'complete)  ;; use 'complete when auto-complete is disabled
   (add-to-list 'completion-styles 'initials t)

   ;; hook AC into completion-at-point
   (defun set-auto-complete-as-completion-at-point-function ()
     (setq completion-at-point-functions '(auto-complete)))
   (add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)


   (set-default 'ac-sources
                '(ac-source-dictionary
                  ac-source-words-in-buffer
                  ac-source-words-in-same-mode-buffers
                  ac-source-words-in-all-buffer))

   (dolist (mode '(magit-log-edit-mode log-edit-mode org-mode text-mode haml-mode
                                       sass-mode yaml-mode csv-mode espresso-mode haskell-mode
                                       html-mode nxml-mode sh-mode smarty-mode clojure-mode
                                       lisp-mode textile-mode markdown-mode tuareg-mode
                                       css-mode less-css-mode))
  (add-to-list 'ac-modes mode))


   ;; Exclude very large buffers from dabbrev
   (defun smp-dabbrev-friend-buffer (other-buffer)
     (< (buffer-size other-buffer) (* 1 1024 1024)))

   (setq dabbrev-friend-buffer-function 'smp-dabbrev-friend-buffer)
   (add-to-list 'ac-dictionary-directories (concat vendor-dir "auto-complete/dict/"))

   (ac-config-default)


#+end_src

** Load yasnippet

#+begin_src emacs-lisp
  (require 'dropdown-list)
  (require 'yasnippet)
  (setq yas/verbosity 0
        yas/snippet-dirs (list (concat dotfiles-dir "/snippets")
                               (concat dotfiles-dir "/snippets-imported"))
        yas/prompt-functions '(yas/dropdown-prompt))

  (yas/global-mode 1)
#+end_src

** TODO Currently unused
#+begin_src emacs-lisp :tangle no
 (setq mac-option-modifier nil
       mac-command-modifier 'meta
      x-select-enable-clipboard t)

;; Trim whitespace before save)
 (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** TODO IDO
#+begin_src emacs-lisp
  (setq  ido-enable-flex-matching t
         ido-use-filename-at-point nil
         ido-auto-merge-work-directories-length 0
         ido-use-virtual-buffers t
         ido-default-buffer-method 'selected-window)
  (ido-mode t)
  (ido-everywhere t)
  (ido-ubiquitous)
#+end_src
* Utility functions
** Insert file as org table at point
#+begin_src emacs-lisp :tangle thomasf-org.el
  (defun insert-file-as-org-table (filename)
    "Insert a file into the current buffer at point, and convert it to an org table."
    (interactive (list (ido-read-file-name "csv file: ")))
    (let* ((start (point))
           (end (+ start (nth 1 (insert-file-contents filename)))))
      (org-table-convert-region start end)))
#+end_src
** Day and night mode (theme switching)
#+begin_src emacs-lisp :tangle thomasf-gui.el
  (when (featurep 'x)
    (defun night-mode ()
      "Switch to night mode (dark color theme)"
      (interactive)
      (load-theme night-mode-theme)
      (message "Night mode on")
      (set-frame-parameter nil 'night-mode-on t))

    (defun day-mode ()
      "Switch to day mode (light color theme)"
      (interactive)
      (load-theme day-mode-theme)
      (message "Night mode off")
      (set-frame-parameter nil 'night-mode-on nil))

    (defun toggle-night-mode ()
      "Toggle between day and night modes"
      (interactive)
      (if (frame-parameter nil 'night-mode-on)
          (day-mode)
        (night-mode))))
#+end_src
** Multi occur all buffers of same mode
#+begin_src emacs-lisp
  (defun get-buffers-matching-mode (mode)
    "Returns a list of buffers where their major-mode is equal to MODE"
    (let ((buffer-mode-matches '()))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (eq mode major-mode)
              (add-to-list 'buffer-mode-matches buf))))
      buffer-mode-matches))

  (defun multi-occur-in-this-mode ()
    "Show all lines matching REGEXP in buffers with this major mode."
    (interactive)
    (multi-occur
     (get-buffers-matching-mode major-mode)
     (car (occur-read-primary-args))))

#+end_src
** Cycle ispell dictionaries
#+begin_src emacs-lisp
  ;; Languages for spellinc cycling
  (let ((langs '("svenska" "english")))
    (setq lang-ring (make-ring (length langs)))
    (dolist (elem langs) (ring-insert lang-ring elem)))

  (defun cycle-ispell-languages ()
    "Cycle spelling dictionaries from a list"
    (interactive)
    (let ((lang (ring-ref lang-ring -1)))
      (ring-insert lang-ring lang)
      (ispell-change-dictionary lang)))
#+end_src
** Intelligent close
#+begin_src emacs-lisp :tangle thomasf-gui.el
  (defun intelligent-close ()
    "quit a frame the same way no matter what kind of frame you are on.

  This method, when bound to C-x C-c, allows you to close an emacs frame the
  same way, whether it's the sole window you have open, or whether it's
  a \"child\" frame of a \"parent\" frame.  If you're like me, and use emacs in
  a windowing environment, you probably have lots of frames open at any given
  time.  Well, it's a pain to remember to do Ctrl-x 5 0 to dispose of a child
  frame, and to remember to do C-x C-x to close the main frame (and if you're
  not careful, doing so will take all the child frames away with it).  This
  is my solution to that: an intelligent close-frame operation that works in
  all cases (even in an emacs -nw session).

  Stolen from http://www.dotemacs.de/dotfiles/BenjaminRutt.emacs.html."
    (interactive)
    (if (eq (car (visible-frame-list)) (selected-frame))
        ;;for parent/master frame...
        (if (> (length (visible-frame-list)) 1)
            ;;close a parent with children present
            (delete-frame (selected-frame))
          ;;close a parent with no children present
          (save-buffers-kill-emacs))
      ;;close a child frame
      (delete-frame (selected-frame))))


#+end_src
** Lorem ipsum paster
#+begin_src emacs-lisp
(defun lorem (paragraphs)
    "Inserts up to 5 paragraphs of lorem ipsum filler text."
    (interactive "nParagraphs: ")
    (let ((lorems '("Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enimad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
                    "\n\nIn non elit turpis, quis accumsan tortor. Vestibulum enim mi, tincidunt eget fringilla a, euismod nec mi. Integer dictum diam sed ante posuere feugiat. Aenean convallis sapien tincidunt leo aliquam posuere. Mauris porta facilisis metus, non commodo mauris interdum sed. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce a diam nec augue tristique placerat eu at odio. Sed fermentum, nunc non condimentum accumsan, dolor nisl mollis quam, sed condimentum massa massa at nisi. Etiam quis ante neque. Mauris feugiat lacus nec lorem vulputate sagittis. Fusce congue ullamcorper nulla, in lacinia felis euismod eu. Integer arcu dolor, tempus eget scelerisque sit amet, fermentum at elit. Maecenas dignissim mollis sapien, nec elementum enim feugiat vel. Mauris lobortis sodales sem vitae venenatis. Aliquam a risus arcu. Aliquam bibendum pretium velit in tempor. Aliquam erat volutpat."
                    "\n\nSed ut nisi ante. Sed sollicitudin blandit tortor eu cursus. Praesent sem augue, cursus vitae sodales a, aliquam eget enim. Nullam velit nulla, ornare vitae vulputate sit amet, blandit ut nisl. Vivamus sodales blandit pretium. In faucibus risus nec purus dapibus laoreet. Aliquam erat volutpat. Phasellus a sem sit amet metus pharetra euismod. Nunc sit amet vehicula purus. Donec lorem metus, feugiat vel ultrices vel, sagittis nec odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In scelerisque, justo eu pretium ultricies, elit eros varius mauris, quis scelerisque lacus lacus sed metus. Phasellus hendrerit, quam in accumsan ullamcorper, magna enim vehicula sem, et vulputate massa dolor eu augue. Pellentesque sed nibh sit amet mi vulputate porttitor at ac tortor. Ut ac augue risus, tincidunt ornare sapien. Suspendisse gravida est lacinia urna interdum scelerisque ut non sem. Sed quis lectus lectus."
                    "\n\nNam et consectetur nisl. Pellentesque rhoncus velit a elit mollis cursus nec ut orci. Vestibulum a purus ligula. Cras blandit, felis et venenatis interdum, urna libero cursus sapien, at auctor sem purus eget quam. Suspendisse pretium sollicitudin leo, quis imperdiet sem faucibus vel. Vestibulum mollis imperdiet urna, pretium porttitor lorem posuere at. Integer aliquam, velit id luctus lobortis, odio ipsum convallis urna, sit amet eleifend lacus mi et leo. Phasellus quis ante in dolor tincidunt lobortis. Proin in massa purus, vitae dignissim elit. Curabitur non enim sit amet lectus volutpat tristique."
                    "\n\nPellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Sed vel neque a nibh tincidunt luctus id a eros. Curabitur leo odio, sodales id malesuada ac, commodo et augue. Aenean auctor justo a nulla lobortis ut tempor mauris mollis. Duis a purus consequat enim vestibulum pretium. Vestibulum diam urna, luctus at pulvinar sed, rhoncus id risus. Maecenas sit amet velit vitae libero viverra aliquet sit amet non mauris. Suspendisse potenti. Duis eu lectus sem. Maecenas aliquam erat vitae tortor congue ut imperdiet lacus consectetur. Praesent nisl ipsum, fermentum id venenatis eu, lobortis eu nunc. Fusce ut enim tellus, ac semper turpis. Proin in ante massa. Curabitur velit lacus, pharetra vel dapibus egestas, posuere quis dui. Morbi aliquet congue nisl, dictum fringilla velit dictum sed. Integer eu consequat nisl. Curabitur aliquam suscipit magna vel pharetra. Duis eget erat vel purus mattis dignissim. Donec mattis, nulla nec imperdiet scelerisque, leo elit tincidunt dui, eget ullamcorper tortor neque nec erat. Aliquam libero augue, suscipit vitae scelerisque vitae, rutrum vitae quam.")))
      (loop for p from 0 to (- paragraphs 1)
            do (insert (nth p lorems)))))

#+end_src
** Recompile / cache everything that makes emacs faster
#+begin_src emacs-lisp
  (defun recompile-dot-lisp ()
     "Recompile emacs lisp code in emacs dotfiles directory"
     (interactive)
     (setq font-lock-verbose nil)
     (setq byte-compile-verbose  nil)
     (byte-recompile-directory (concat dotfiles-dir "vendor") 0)
     (byte-recompile-directory (concat dotfiles-dir "elpa") 0)
     (byte-recompile-directory (concat dotfiles-dir "themes") 0)
     (byte-compile-file "~/.emacs-private.el")
     (byte-compile-file (concat dotfiles-dir "init.el"))
     (byte-compile-file (concat dotfiles-dir "thomasf-init.el"))
     (byte-compile-file (concat dotfiles-dir "thomasf-org.el"))
     (byte-compile-file (concat dotfiles-dir "thomasf-gui.el"))
     (byte-compile-file (concat dotfiles-dir "thomasf-emacs.el"))
     (yas/compile-top-level-dir (concat dotfiles-dir "snippets"))
     (yas/compile-top-level-dir (concat dotfiles-dir "snippets-imported"))
     (byte-recompile-directory (concat dotfiles-dir "snippets") 0)
     (byte-recompile-directory (concat dotfiles-dir "snippets-imported") 0))


#+end_src


** Tab/space/indent utilities
#+begin_src emacs-lisp
   (defun untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (indent-buffer)
    (untabify-buffer)
    (delete-trailing-whitespace))
#+end_src
** Fullscreen toggle
This is only for x, I would guess.
#+begin_src emacs-lisp :tangle thomasf-gui.el
  (defun toggle-fullscreen ()
    (interactive)
    (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                           '(2 "_NET_WM_STATE_FULLSCREEN" 0)))
#+end_src
** Comment/uncomment
#+begin_src emacs-lisp
  (defun comment-or-uncomment-line (&optional lines)
    "Comment current line. Argument gives the number of lines
  forward to comment"
    (interactive "P")
    (comment-or-uncomment-region
     (line-beginning-position)
     (line-end-position lines)))

  (defun comment-or-uncomment-region-or-line (&optional lines)
    (interactive "P")
    (if mark-active
        (if (< (mark) (point))
            (comment-or-uncomment-region (mark) (point))
          (comment-or-uncomment-region (point) (mark)))
      (comment-or-uncomment-line lines)))

#+end_src
** Sudo edit
#+begin_src emacs-lisp
  (defun sudo-edit (&optional arg)
    (interactive "p")
    (if arg
        (find-file (concat "/sudo::" (ido-read-file-name "File: ")))
      (find-alternate-file (concat "/sudo::" buffer-file-name))))
#+end_src
** Eval-and-replace
#+begin_src emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+end_src

** Recentf-ido-find-file
This is provided by other things I use
#+begin_src emacs-lisp :tangle no
  (defun recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
      (when file
        (find-file file))))
#+end_src

** Paredit for non lisps
#+begin_src emacs-lisp
  (defun esk-paredit-nonlisp ()
    "Turn on paredit mode for non-lisps."
    (interactive)
    (set (make-local-variable 'paredit-space-for-delimiter-predicates)
         '((lambda (endp delimiter) nil)))
    (paredit-mode 1))
#+end_src

* Modes, modules and hooks
** Generic hooks
*** All modes hook
#+begin_src emacs-lisp
(defun my-all-modes-hook ()
  "Hook that should be run every time an major mode is entered"
  (turn-on-undo-tree-mode)
  )

(add-hook 'after-change-major-mode-hook  'my-all-modes-hook)
#+end_src
*** Text mode hook
#+begin_src emacs-lisp
(defun my-textmode-hook ()
  ;;(table-recognize)
  ;;(turn-on-auto-fill)
  (turn-on-undo-tree-mode)
  )
(add-hook 'text-mode-hook 'my-textmode-hook)
#+end_src
*** Programming hook
#+begin_src emacs-lisp
  (defun my-programming-hook ()
    "Enable things that are convenient across all programming buffers."
    (set (make-local-variable 'comment-auto-fill-only-comments) t)
    (make-local-variable 'column-number-mode)
    (undo-tree-mode)
    (setq save-place t)
    (if window-system (hl-line-mode +1)))
#+end_src
** Programming languages
*** Erlang
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.erl$" . erlang-mode))
(add-to-list 'auto-mode-alist '("\\.hrl$" . erlang-mode))

(defun my-erlang-hook ()
  (my-programming-hook)
)

#+end_src
*** Haskell
#+begin_src emacs-lisp
  (eval-after-load "haskell-mode"
    '(progn

       ;; (defun pretty-lambdas-haskell ()
       ;;   (font-lock-add-keywords
       ;;    nil `((,(concat "(?\\(" (regexp-quote "\\") "\\)")
       ;;           (0 (progn (compose-region (match-beginning 1) (match-end 1)
       ;;                                     ,(make-char 'greek-iso8859-7 107))
       ;;                     nil))))))

       (defun my-haskell-mode-hook ()
         "My haskell-mode hook"
         (my-programming-hook)
         ;; (when (window-system)
         ;;   (add-hook 'haskell-mode-hook 'pretty-lambdas-haskell))
         (turn-on-haskell-doc-mode)
         (turn-on-haskell-indentation)
         (rainbow-delimiters-mode)
         (eldoc-mode))

       (add-hook 'haskell-mode-hook 'my-haskell-mode-hook)

       ))
#+end_src
*** CoffeeScript
#+begin_src emacs-lisp
  (autoload 'coffee-mode "coffee-mode" "Coffee Mode." t)

  (add-to-list 'auto-mode-alist '("\\.coffee$" . coffee-mode))
  (add-to-list 'auto-mode-alist '("Cakefile" . coffee-mode))

  (eval-after-load "coffee-mode"
    '(progn
       (setq coffee-cleanup-whitespace nil
             coffee-debug-mode t
             coffee-tab-width 3)

       (defun my-coffee-mode-hook ()
         "My coffee-mode hook"
         (my-programming-hook)
         (electric-indent-mode -1)
         (electric-layout-mode -1)
         (setq ac-sources '(ac-source-dictionary ac-source-words-in-buffer ac-source-yasnippet ac-source-words-in-same-mode-buffers))
         (auto-complete-mode)
         ;;(paredit-mode)
         (whitespace-mode)
         ;;(glasses-mode)
         (flymake-coffee-load)
         )

       (add-hook 'coffee-mode-hook 'my-coffee-mode-hook)
       ))
#+end_src
*** TODO JavaScript

TODO: maybe possible to do this in pretty-mode
#+begin_src emacs-lisp

#+end_src

#+begin_src emacs-lisp
(font-lock-add-keywords
 'js-mode `(("\\(function *\\)("
              (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                        "ƒ")
                        nil)))))

(font-lock-add-keywords 'js-mode
                        '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
                           1 font-lock-warning-face t)))

(add-to-list 'auto-mode-alist '("\\.json$" . js-mode))
(setq js-indent-level 2)

(defun my-js-mode-hook ()
  "My js-mode hook"
  ;; electric-layout-mode doesn't play nice with js-mode
  (my-programming-hook)
  (electric-layout-mode -1)

  ;; rainbow-delemiters-mode does not seem to work very well with js-mode
  ;; (rainbow-delimiters-mode)

  (paredit-mode)
  )

(add-hook 'js-mode-hook 'my-js-mode-hook)

#+end_src
*** TODO lisp
- Should all lisp modes be in the same place?
Most of this is just copied without ever read

Disable slime for now
#+begin_src emacs-lisp :tangle no
  (require 'slime)
  (require 'geiser)
  (setq geiser-scheme-dir "/usr/local/share/geiser")

  (eval-after-load "slime"
    '(progn
       (setq slime-lisp-implementations '((sbcl ("sbcl"))))
       (slime-setup '(slime-asdf
                      slime-autodoc
                      slime-editing-commands
                      slime-fancy-inspector
                      slime-fontifying-fu
                      slime-fuzzy
                      slime-indentation
                      slime-mdot-fu
                      slime-package-fu
                      slime-references
                      slime-repl
                      slime-sbcl-exts
                      slime-scratch
                      slime-xref-browser))
       (slime-autodoc-mode)
       (setq slime-complete-symbol*-fancy t
             slime-complete-sumbol-function 'slime-fuzzy-complete-symbol)))
#+end_src


#+begin_src emacs-lisp


  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'my-programming-hook)
  (add-hook 'lisp-mode-hook 'my-programming-hook)

  (add-hook 'emacs-lisp-mode-hook 'emacs-lisp-remove-elc-on-save)
  (add-hook 'emacs-lisp-mode-hook '(lambda () "rainbown-delimiters" (rainbow-delimiters-mode)))

  (when (functionp 'paredit-mode)
    (add-hook 'emacs-lisp-mode-hook (lambda () (paredit-mode +1)))
    (add-hook 'lisp-mode-hook (lambda () (paredit-mode +1))))

  (defun emacs-lisp-remove-elc-on-save ()
    "If you're saving an elisp file, likely the .elc is no longer valid."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              (lambda ()
                (if (file-exists-p (concat buffer-file-name "c"))
                    (delete-file (concat buffer-file-name "c"))))))

  (font-lock-add-keywords 'emacs-lisp-mode
                          '(("(\\|)" . 'paren-face)))

  (font-lock-add-keywords 'scheme-mode
                          '(("(\\|)" . 'paren-face)))

  (font-lock-add-keywords 'lisp-mode
                          '(("(\\|)" . 'paren-face)))

  (font-lock-add-keywords 'lfe-mode
                          '(("(\\|)" . 'paren-face)))

  (font-lock-add-keywords 'hen-mode
                          '(("(\\|)" . 'paren-face)))

  (define-key lisp-mode-shared-map (kbd "C-c l") "lambda")
  (define-key read-expression-map (kbd "TAB") 'lisp-complete-symbol)
  (define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
  (define-key lisp-mode-shared-map (kbd "C-\\") 'lisp-complete-symbol)
  (define-key lisp-mode-shared-map (kbd "C-c v") 'eval-buffer)

  (defface paren-face
    '((((class color) (background dark))
       (:foreground "grey20"))
      (((class color) (background light))
       (:foreground "grey55")))
    "Face used to dim parentheses."
    :group 'faces)

  (autoload 'scheme-get-current-symbol-info "scheme-complete" nil t)
  (add-hook 'scheme-mode-hook
    (lambda ()
      (make-local-variable 'eldoc-documentation-function)
      (setq eldoc-documentation-function 'scheme-get-current-symbol-info)
      (eldoc-mode)))

#+end_src
*** PHP
#+begin_src emacs-lisp
  (autoload 'php-mode "php-mode" "PHP Mode." t)

  (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))

  (eval-after-load "php-mode"
    '(progn
       (defun my-php-mode-hook ()
         "My php mode hook"
         (my-programming-hook)
         (flymake-php-load))

       (add-hook 'php-mode-hook 'my-php-mode-hook)
       ))
#+end_src
*** Python
#+begin_src emacs-lisp
;;(require 'python-mode)
(add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
(add-to-list 'interpreter-mode-alist '("python" . python-mode))

;; if ipythonm use ipython
(when (executable-find "ipython")
  ;;(require 'ipython)
  (setq org-babel-python-mode 'python-mode))

;;(require 'cython-mode)
;;(add-to-list 'auto-mode-alist '("\\.pyx\\'" . cython-mode))
;;(add-to-list 'auto-mode-alist '("\\.pxd\\'" . cython-mode))
;;(add-to-list 'auto-mode-alist '("\\.pxi\\'" . cython-mode))

(defun my-python-mode-hook ()
  (my-programming-hook)
  (electric-indent-mode -1)
  ;;(glasses-mode)
  ;(;auto-complete-mode)
  ;;(require 'ac-python)
  ;;(setq ac-sources '(ac-source-python ac-source-yasnippet))
  (whitespace-mode)
  )

(add-hook 'python-mode-hook 'my-python-mode-hook)
#+end_src
*** Ruby
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Guardfile$" . ruby-mode))
  (add-to-list 'completion-ignored-extensions ".rbc")

  (eval-after-load 'ruby-mode
    '(progn
       (require 'ruby-block)))

  (defun my-ruby-hook ()
    "My ruby hook"
    (my-programming-hook)
    (ruby-block-mode t)
    (setq ac-sources '(ac-source-yasnippet ac-source-words-in-buffer))
    (auto-complete-mode))

  (add-hook 'ruby-mode-hook 'my-ruby-hook)
#+end_src

*** Java
#+begin_src emacs-lisp
  (eval-after-load  "java-mode"
    '(progn
       (setq eclim-eclipse-dirs "~/programming/applib/eclim_eclipse")
       (require 'eclim)))
#+end_src
** Markup/text languages
*** Multi web mode

#+begin_src emacs-lisp
  (require 'multi-web-mode)
  (setq mweb-default-major-mode 'html-mode)
  (setq mweb-tags '((php-mode "<\\?php\\|<\\? \\|<\\?=" "\\?>")
                    (js-mode "<script +\\(type=\"text/javascript\"\\|language=\"javascript\"\\)[^>]*>" "</script>")
                    (css-mode "<style +type=\"text/css\"[^>]*>" "</style>")))
  ;; (setq mweb-filename-extensions '("php" "htm" "html" "ctp" "phtml" "php4" "php5"))
  (setq mweb-filename-extensions '("php" "php4" "php5"))
  (multi-web-global-mode 1)
#+end_src

*** CSS
#+begin_src emacs-lisp
(defun my-css-mode-hook ()
  "My css-mode hook"
  (my-programming-hook)
  (if window-system (rainbow-mode)))


(add-hook 'css-mode-hook 'my-css-mode-hook)
(setq css-indent-offset 3)

(add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
#+end_src

*** Markdown
#+begin_src emacs-lisp
  (autoload 'markdown-mode "markdown-mode" "Markdown mode" t)

  (add-to-list 'auto-mode-alist '("\\.markdown$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.mdwn$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.mkd$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.mkdown$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.mdtext$" . markdown-mode))

  (defun my-markdown-mode-hook ()
    "My markdown-mode hook"
    (setq markdown-command "pandoc -f markdown -t html")
    (define-key markdown-mode-map (kbd "<tab>") nil)
    ;(turn-on-auto-fill)
    (undo-tree-mode)
    (artbollocks-mode)
    )

  (add-hook 'markdown-mode-hook 'my-markdown-mode-hook)
#+end_src
*** HTML
#+begin_src emacs-lis
(add-to-list 'auto-mode-alist '("\\.html$" . html-mode))
(add-to-list 'auto-mode-alist '("\\.rhtml$" . html-mode))
(add-to-list 'auto-mode-alist '("\\.mustache$" . html-mode))
(add-to-list 'auto-mode-alist '("\\.hb$" . html-mode))

(defun my-html-mode-hook ()
  "My html-mode-hook"
  (my-programming-hook)
  (zencoding-mode)
  (setq ac-sources '(ac-source-yasnippet))
  (auto-complete-mode))

(add-hook 'html-mode-hook 'my-html-mode-hook)
#+end_src

*** YAML
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
#+end_src
** Other modes
*** Gitolite configuration files
#+begin_src emacs-lisp
(require 'gl-conf-mode)
(add-to-list 'auto-mode-alist '("gitolite\\.conf\\'" . gl-conf-mode))

#+end_src
*** Git commit mode
#+begin_src emacs-lisp
(require 'git-commit)
(add-hook 'git-commit-mode-hook 'turn-on-flyspell)
(add-hook 'git-commit-mode-hook (lambda () (toggle-save-place 0)))
#+end_src
*** GNUS
#+begin_src emacs-lisp
;; Make Gnus NOT ignore [Gmail] mailboxes
(setq gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

#+end_src


* ORGmode!
** TODO Orgmode
!VERY MUCH STILL WIP!
Inspirations:
- http://orgmode
- http://doc.norang.ca/org-mode.html
** Load stuff
#+begin_src emacs-lisp :tangle thomasf-org.el
  (eval-after-load "org-agenda"
    '(progn
       (require 'org-checklist)))
#+end_src
** Set up basic paths for org and org-agenda
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-directory notes-dir)
  (setq org-agenda-files (file-expand-wildcards (concat notes-dir "agenda/*.org")))
  (setq org-agenda-text-search-extra-files (file-expand-wildcards (concat notes-dir "org/*.org")))
  (setq org-default-notes-file (concat notes-dir "agenda/refile.org"))
  (setq org-mobile-inbox-for-pull (concat notes-dir "from-mobile.org"))
  (setq org-icalendar-alarm-time 240)
#+end_src
** Settings
*** Misc
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-use-fast-todo-selection t
        org-treat-S-cursor-todo-selection-as-state-change nil
        org-startup-indented t
        ;; org-log-done t
        org-ellipsis "…"
        org-outline-path-complete-in-steps t
        org-tab-follows-link t
        org-completion-use-ido t)
#+end_src
*** Agenda
**** Misc
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-agenda-span 10
        org-agenda-show-all-dates nil
        org-agenda-dim-blocked-tasks nil
        org-agenda-tags-todo-honor-ignore-options t)
#+end_src
**** icalendar export
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-icalendar-include-body t
        org-icalendar-include-sexps t
        org-icalendar-store-UID t)
#+end_src

**** Agenda commands
#+begin_src emacs-lisp :tangle thomasf-org.el
  (eval-after-load "org-agenda"
    '(progn
       ;; Custom agenda command definitions
       (setq org-agenda-custom-commands
             (quote (("N" "Notes" tags "NOTE"
                      ((org-agenda-overriding-header "Notes")
                       (org-tags-match-list-sublevels t)))
                     ("h" "Habits" tags-todo "STYLE=\"habit\""
                      ((org-agenda-overriding-header "Habits")
                       (org-agenda-sorting-strategy
                        '(todo-state-down effort-up category-keep))))
                     (" " "Agenda"
                      ((agenda "" nil)
                       (tags "REFILE"
                             ((org-agenda-overriding-header "Tasks to Refile")
                              (org-tags-match-list-sublevels nil)))
                       (tags-todo "-CANCELLED/!"
                                  ((org-agenda-overriding-header "Stuck Projects")
                                   (org-tags-match-list-sublevels 'indented)
                                   (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                       (tags-todo "-WAITING-CANCELLED/!NEXT"
                                  ((org-agenda-overriding-header "Next Tasks")
                                   (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                                   (org-agenda-todo-ignore-scheduled t)
                                   (org-agenda-todo-ignore-deadlines t)
                                   (org-tags-match-list-sublevels t)
                                   (org-agenda-sorting-strategy
                                    '(todo-state-down effort-up category-keep))))
                       (tags-todo "-REFILE-CANCELLED/!-HOLD-WAITING"
                                  ((org-agenda-overriding-header "Tasks")
                                   (org-agenda-skip-function 'bh/skip-project-tasks-maybe)
                                   (org-agenda-todo-ignore-scheduled t)
                                   (org-agenda-todo-ignore-deadlines t)
                                   (org-agenda-sorting-strategy
                                    '(category-keep))))
                       (tags-todo "-CANCELLED/!"
                                  ((org-agenda-overriding-header "Projects")
                                   (org-agenda-skip-function 'bh/skip-non-projects)
                                   (org-agenda-todo-ignore-scheduled 'future)
                                   (org-agenda-todo-ignore-deadlines 'future)
                                   (org-agenda-sorting-strategy
                                    '(category-keep))))
                       (tags-todo "-CANCELLED/!WAITING|HOLD"
                                  ((org-agenda-overriding-header "Waiting and Postponed Tasks")
                                   (org-agenda-skip-function 'bh/skip-projects-and-habits)
                                   (org-agenda-todo-ignore-scheduled t)
                                   (org-agenda-todo-ignore-deadlines t)))
                       (tags "-REFILE/"
                             ((org-agenda-overriding-header "Tasks to Archive")
                              (org-agenda-skip-function 'bh/skip-non-archivable-tasks))))
                      nil)
                     ("r" "Tasks to Refile" tags "REFILE"
                      ((org-agenda-overriding-header "Tasks to Refile")
                       (org-tags-match-list-sublevels nil)))
                     ("#" "Stuck Projects" tags-todo "-CANCELLED/!"
                      ((org-agenda-overriding-header "Stuck Projects")
                       (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                     ("n" "Next Tasks" tags-todo "-WAITING-CANCELLED/!NEXT"
                      ((org-agenda-overriding-header "Next Tasks")
                       (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                       (org-agenda-todo-ignore-scheduled t)
                       (org-agenda-todo-ignore-deadlines t)
                       (org-tags-match-list-sublevels t)
                       (org-agenda-sorting-strategy
                        '(todo-state-down effort-up category-keep))))
                     ("R" "Tasks" tags-todo "-REFILE-CANCELLED/!-HOLD-WAITING"
                      ((org-agenda-overriding-header "Tasks")
                       (org-agenda-skip-function 'bh/skip-project-tasks-maybe)
                       (org-agenda-sorting-strategy
                        '(category-keep))))
                     ("p" "Projects" tags-todo "-CANCELLED/!"
                      ((org-agenda-overriding-header "Projects")
                       (org-agenda-skip-function 'bh/skip-non-projects)
                       (org-agenda-todo-ignore-scheduled 'future)
                       (org-agenda-todo-ignore-deadlines 'future)
                       (org-agenda-sorting-strategy
                        '(category-keep))))
                     ("w" "Waiting Tasks" tags-todo "-CANCELLED/!WAITING|HOLD"
                      ((org-agenda-overriding-header "Waiting and Postponed tasks"))
                      (org-agenda-skip-function 'bh/skip-projects-and-habits)
                      (org-agenda-todo-ignore-scheduled 'future)
                      (org-agenda-todo-ignore-deadlines 'future))
                     ("A" "Tasks to Archive" tags "-REFILE/"
                      ((org-agenda-overriding-header "Tasks to Archive")
                       (org-agenda-skip-function 'bh/skip-non-archivable-tasks))))))))
#+end_src

**** Agenda skip functions
#+begin_src emacs-lisp :tangle thomasf-org.el
  (eval-after-load "org-agenda"
    '(progn
       (defun bh/skip-non-stuck-projects ()
         "Skip trees that are not stuck projects"
         (save-restriction
           (widen)
           (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
             (if (bh/is-project-p)
                 (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                        (has-next (save-excursion
                                    (forward-line 1)
                                    (and (< (point) subtree-end)
                                         (re-search-forward "^\\*+ \\(NEXT\\) " subtree-end t)))))
                   (if has-next
                       next-headline
                     nil)) ; a stuck project, has subtasks but no next task
               next-headline))))

       (defun bh/skip-non-projects ()
         "Skip trees that are not projects"
         (bh/list-sublevels-for-projects-indented)
         (if (save-excursion (bh/skip-non-stuck-projects))
             (save-restriction
               (widen)
               (let ((subtree-end (save-excursion (org-end-of-subtree t))))
                 (if (bh/is-project-p)
                     nil
                   subtree-end)))
           (org-end-of-subtree t)))

       (defun bh/skip-project-trees-and-habits ()
         "Skip trees that are projects"
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((bh/is-project-p)
               subtree-end)
              ((org-is-habit-p)
               subtree-end)
              (t
               nil)))))

       (defun bh/skip-projects-and-habits-and-single-tasks ()
         "Skip trees that are projects, tasks that are habits, single non-project tasks"
         (save-restriction
           (widen)
           (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
             (cond
              ((org-is-habit-p)
               next-headline)
              ((bh/is-project-p)
               next-headline)
              ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
               next-headline)
              (t
               nil)))))

       (defun bh/skip-project-tasks-maybe ()
         "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
         (save-restriction
           (widen)
           (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                  (next-headline (save-excursion (or (outline-next-heading) (point-max))))
                  (limit-to-project (marker-buffer org-agenda-restrict-begin)))
             (cond
              ((bh/is-project-p)
               next-headline)
              ((org-is-habit-p)
               subtree-end)
              ((and (not limit-to-project)
                    (bh/is-project-subtree-p))
               subtree-end)
              ((and limit-to-project
                    (bh/is-project-subtree-p)
                    (member (org-get-todo-state) (list "NEXT")))
               subtree-end)
              (t
               nil)))))

       (defun bh/skip-projects-and-habits ()
         "Skip trees that are projects and tasks that are habits"
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((bh/is-project-p)
               subtree-end)
              ((org-is-habit-p)
               subtree-end)
              (t
               nil)))))

       (defun bh/skip-non-subprojects ()
         "Skip trees that are not projects"
         (let ((next-headline (save-excursion (outline-next-heading))))
           (if (bh/is-subproject-p)
               nil
             next-headline)))))
#+end_src
*** Refile
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-refile-targets (quote ((org-agenda-files :level . 1))))
  (setq org-refile-use-outline-path (quote file))
#+end_src
*** Todo
**** Default todo states
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE"))))
#+end_src
**** Todo state triggers
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING" . t) ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

#+end_src
**** TODO Todo faces
#+begin_src emacs-lisp :tangle no
  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

#+end_src
*** Default tags
#+begin_src emacs-lisp :tangle thomasf-org.el
  ; Tags with fast selection keys
  (setq org-tag-alist (quote ((:startgroup)
                              ("@errand" . ?e)
                              ("@office" . ?o)
                              ("@home" . ?H)
                              (:endgroup)
                              ("PHONE" . ?p)
                              ("WAITING" . ?w)
                              ("HOLD" . ?h)
                              ("PERSONAL" . ?P)
                              ("WORK" . ?W)
                              ("NOTE" . ?n)
                              ("CANCELLED" . ?c)
                              ("FLAGGED" . ??))))

#+end_src
*** Capture templates
#+begin_src emacs-lisp :tangle thomasf-org.el
  ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, and org-protocol
  (setq org-capture-templates
        (quote (("t" "todo" entry (file org-default-notes-file)
                 "* TODO %?\n%U\n%a\n  %i" :clock-in t :clock-resume t)
                ("n" "note" entry (file org-default-notes-file)
                 "* %? :NOTE:\n%U\n%a\n  %i" :clock-in t :clock-resume t)
                ("j" "Journal" entry (file+datetree (concat notes-dir "org/diary.org"))
                 "* %?\n%U\n  %i" :clock-in t :clock-resume t)
                ("w" "org-protocol" entry (file org-default-notes-file)
                 "* TODO Review %c\n%U\n  %i" :immediate-finish t)
                ("p" "Phone call" entry (file org-default-notes-file)
                 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                ("h" "Habit" entry (file org-default-notes-file)
                 "* NEXT %?\n%U\n%a\nSCHEDULED: %t .+1d/3d\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n  %i"))))
#+end_src
*** Clocking
#+begin_src emacs-lisp :tangle thomasf-org.el
;;Resume clock when the agenda is loaded
 (eval-after-load "org-agenda"
    '(progn

(org-clock-persistence-insinuate)
))
  ;; Clocking
  ;;
  ;; Resume clocking task when emacs is restarted

  ;;
  ;; Show lot sof clocking history so it's easy to pick items off the C-F11 list
  (setq org-clock-history-length 36)
  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Change tasks to NEXT when clocking in
  ;;(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
  ;; Separate drawers for clocking and logs
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
  ;; Save clock data and state changes and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
  ;; Clock out when moving task to a done state
  (setq org-clock-out-when-done t)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist t)
  ;; Do not prompt to resume an active clock
  (setq org-clock-persist-query-resume nil)
  ;; Enable auto clock resolution for finding open clocks
  (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)


#+end_src
** Integrations
*** yasnippet
#+begin_src emacs-lisp :tangle thomasf-org.el

  (defun yas/org-very-safe-expand ()
    (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

  (add-hook 'org-mode-hook
            (lambda ()
              (make-variable-buffer-local 'yas/trigger-key)
              (setq yas/trigger-key [tab])
              (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
              (define-key yas/keymap [tab] 'yas/next-field)))
#+end_src
** Babel configuration
*** TODO Always execute code blocks in these languages in babel mode
#+begin_src emacs-lisp :tangle thomasf-org.el
  (eval-after-load "org"
    '(progn
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((perl . t)
          (ruby . t)
          (sh . t)
          (python . t)
          (emacs-lisp . t)))))

#+end_src

*** Don't confirm babel execution!
#+begin_src emacs-lisp :tangle thomasf-org.el
  (setq org-confirm-babel-evaluate nil)
#+end_src
*** TODO Use inline formatting with org-babel
To me, the following feels a bit slow and/or confusing).. Use [C-c '] instead.
#+begin_src emacs-lisp :tangle no
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+end_src

** Support functions
#+begin_src emacs-lisp :tangle thomasf-org.el
  (defun open-index-notes ()
    "Open my index personal org-wiki-whatever index file"
    (interactive)
    (find-file-read-only "~/notes/index.org"))
#+end_src
** MAJOR block'o'code
#+begin_src emacs-lisp :tangle thomasf-org.el
(defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))


  ;; (define-key mode-specific-map [?a] 'org-agenda)

  ;; (eval-after-load "org"
  ;;   '(progn
  ;;      (define-prefix-command 'org-todo-state-map)
  ;;      (define-key org-mode-map "\C-cx" 'org-todo-state-map)

  ;;      (define-key org-todo-state-map "x"
  ;;        #'(lambda nil (interactive) (org-todo "CANCELLED")))
  ;;      )
  ;;   )




  ; Allow setting single tags without the menu
  ; (setq org-fast-tag-selection-single-key (quote expert))


  ; DIsable orgmode default stuck projects ist
  (setq org-stuck-projects (quote ("" nil nil "")))

  ; Disable priorities
  ; (setq org-enable-priority-commands nil)





  ;; enable flyspell for all org-mode buffers
  ;;(add-hook 'org-mode-hook 'turn-on-flyspell 'append)
  ;; enable auto revert for all org-mode buffers
  (add-hook 'org-mode-hook 'turn-on-auto-revert-mode 'append)

  ;; Disable default key bindings for include/remove from org agenda
  (add-hook 'org-mode-hook
            (lambda ()
              (org-defkey org-mode-map "\C-c[" 'undefined)
              (org-defkey org-mode-map "\C-c]" 'undefined)))

  ;; Make windmove work in org-mode:
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)


  ;; support functions
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)



#+end_src

** TODO clocking
leaving this untangeled for now, not sure if I even want clocking at all
#+begin_src emacs-lisp :tangle no
  (setq bh/keep-clock-running nil)

  (defun bh/clock-in-to-next (kw)
    "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO"))
             (bh/is-task-p))
        "NEXT")
       ((and (member (org-get-todo-state) (list "NEXT"))
             (bh/is-project-p))
        "TODO"))))


  (defun bh/punch-in (arg)
    "Start continuous clocking and set the default task to the
  selected task.  If no task is selected set the Organization task
  as the default task."
    (interactive "p")
    (setq bh/keep-clock-running t)
    (if (equal major-mode 'org-agenda-mode)
        ;;
        ;; We're in the agenda
        ;;
        (let* ((marker (org-get-at-bol 'org-hd-marker))
               (tags (org-with-point-at marker (org-get-tags-at))))
          (if (and (eq arg 4) tags)
              (org-agenda-clock-in '(16))
            (bh/clock-in-organization-task-as-default)))
      ;;
      ;; We are not in the agenda
      ;;
      (save-restriction
        (widen)
                                          ; Find the tags on the current task
        (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
            (org-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))))

  (defun bh/punch-out ()
    (interactive)
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out))
    (org-agenda-remove-restriction-lock))

  (defun bh/clock-in-default-task ()
    (save-excursion
      (org-with-point-at org-clock-default-task
        (org-clock-in))))

  (defun bh/clock-in-parent-task ()
    "Move point to the parent (project) task if any and clock in"
    (let ((parent-task))
      (save-excursion
        (save-restriction
          (widen)
          (while (and (not parent-task) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (if parent-task
              (org-with-point-at parent-task
                (org-clock-in))
            (when bh/keep-clock-running
              (bh/clock-in-default-task)))))))

  (defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")

  (defun bh/clock-in-organization-task-as-default ()
    (interactive)
    (org-with-point-at (org-id-find bh/organization-task-id 'marker)
      (org-clock-in '(16))))

  (defun bh/clock-out-maybe ()
    (when (and bh/keep-clock-running
               (not org-clock-clocking-in)
               (marker-buffer org-clock-default-task)
               (not org-clock-resolving-clocks-due-to-idleness))
      (bh/clock-in-parent-task)))

  (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)

#+end_src

* Key bindings
** Global
*** Common
#+begin_src emacs-lisp
  (global-set-key (kbd "<C-f1>") 'open-index-notes)
  (global-set-key [f1] 'eshell)
  (global-set-key [f2] 'split-window-horizontally)
  (global-set-key [f3] 'split-window-vertically)
  (global-set-key [f4] 'delete-window)
  ;;(global-set-key [f5] 'anything)
  (global-set-key [f5] 'find-file-in-project)
  (global-set-key [f6] 'multi-occur-in-this-mode)
  (global-set-key [f7] 'cycle-ispell-languages)

  (global-set-key [f8] 'org-search-view)
  (global-set-key [f12] 'menu-bar-mode)
#+end_src

#+begin_src emacs-lisp :tangle thomasf-gui.el
  (global-set-key [f11] 'toggle-night-mode)
#+end_src

*** Window navigation
#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src
*** Window resizing
#+begin_src emacs-lisp
(global-set-key (kbd "S-C-<left>")   'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>")  'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>")   'shrink-window)
(global-set-key (kbd "S-C-<up>")     'enlarge-window)
#+end_src
*** Searching
#+begin_src emacs-lisp
(global-set-key (kbd "C-s")      'isearch-forward-regexp)
(global-set-key (kbd "C-r")      'isearch-backward-regexp)
(global-set-key (kbd "C-M-s")    'isearch-forward)
(global-set-key (kbd "C-M-r")    'isearch-backward)
#+end_src
*** TODO Proper delete functionality
#+begin_src emacs-lisp :tangle no
(global-set-key (kbd "<backspace>") 'backward-kill-word)
(global-set-key (kbd "C-<backspace>") 'backward-delete-char)
#+end_src

*** Replace basic emacs functionality

#+begin_src emacs-lisp
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
;; This is your old M-x.
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+end_src

#+begin_src emacs-lisp :tangle thomasf-gui.el
(global-set-key "\C-x\C-c" 'intelligent-close)
#+end_src

*** Isearch
#+begin_src emacs-lisp
;; Activate occur easily inside isearch
(define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
#+end_src

** org-mode
#+begin_src emacs-lisp :tangle thomasf-org.el
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)
(global-set-key (kbd "C-M-r") 'org-capture)
#+end_src



* TODO O DET SOM ÄR PÅGÅENDE
#+begin_src emacs-lisp
;; Activate occur easily inside isearch
(define-key isearch-mode-map (kbd "C-o")
  (lambda () (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))

;; sexp+whitespace deletion quickies
(defun clear-whitespace ()
  (interactive)
  (set-mark-command nil)
  (search-backward-regexp "[^[:space:]
]")
  (forward-char)
  (kill-region (point) (mark)))

(global-set-key (kbd "s-<backspace>") 'clear-whitespace)
(global-set-key (kbd "C-M-<backspace>") (lambda ()
                                          (interactive)
                                          (backward-kill-sexp)
                                          (clear-whitespace)))
#+end_src
